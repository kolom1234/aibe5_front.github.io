<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>틈새 (Teumsae) - 서울의 발견</title>

    <link
        href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;700&family=Playfair+Display:ital,wght@0,400;0,700;1,400&display=swap"
        rel="stylesheet">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="stylesheet" href="styles.css">
</head>

<body>

    <div class="search-container">
        <div class="search-bar">
            <i class="fa-solid fa-magnifying-glass"></i>
            <input type="text" placeholder="서울의 숨겨진 틈새를 검색하세요...">
        </div>
    </div>

    <button id="btn-survey" class="top-btn" onclick="toggleSurvey()">
        <i class="fa-solid fa-list-check"></i> 여행 취향 탐색
    </button>

    <button id="btn-filter" class="top-btn" onclick="toggleFilter()">
        <i class="fa-solid fa-sliders"></i> 필터
    </button>

    <button id="btn-back" class="top-btn" onclick="goBack()">
        <i class="fa-solid fa-arrow-left"></i> 전체 지도로 돌아가기
    </button>

    <aside id="survey-panel" class="side-panel">
        <h2 class="panel-header">여행 취향 찾기</h2>
        <div class="form-group">
            <label class="form-label">관심 장소 유형</label>
            <div class="radio-group">
                <input type="checkbox" id="t1" class="radio-btn"><label for="t1" class="radio-label">전시/미술</label>
                <input type="checkbox" id="t2" class="radio-btn"><label for="t2" class="radio-label">콘서트</label>
                <input type="checkbox" id="t3" class="radio-btn"><label for="t3" class="radio-label">상권/쇼핑</label>
                <input type="checkbox" id="t4" class="radio-btn"><label for="t4" class="radio-label">고궁/박물관</label>
            </div>
        </div>
        <div class="form-group">
            <label class="form-label">분위기</label>
            <div class="radio-group">
                <input type="radio" name="vibe" id="v1" class="radio-btn"><label for="v1"
                    class="radio-label">정적인</label>
                <input type="radio" name="vibe" id="v2" class="radio-btn"><label for="v2"
                    class="radio-label">활동적인</label>
            </div>
        </div>
        <div class="form-group">
            <label class="form-label">활동 반경</label>
            <div class="radio-group">
                <input type="radio" name="io" id="io1" class="radio-btn"><label for="io1" class="radio-label">실내</label>
                <input type="radio" name="io" id="io2" class="radio-btn"><label for="io2" class="radio-label">야외</label>
            </div>
        </div>
        <div class="form-group">
            <label class="form-label">이동 수단</label>
            <select style="width:100%; padding: 10px; background:#333; color:white; border:none;">
                <option>지하철</option>
                <option>버스</option>
                <option>자차</option>
                <option>공유 킥보드/자전거</option>
            </select>
        </div>

        <button class="submit-btn" onclick="submitSurvey()">추천 장소 보기</button>

        <div id="survey-result">
            <h4 style="color:var(--accent-color); margin-bottom:10px;">추천 결과</h4>
            <p style="font-size:0.9rem; line-height:1.5;">분석 결과, 회원님의 취향은 <strong>종로구 서촌</strong>과 <strong>성수동</strong>의
                숨겨진 갤러리와 일치합니다.<br><br>지도에 마커를 표시했습니다.</p>
        </div>
    </aside>

    <aside id="filter-panel" class="side-panel">
        <h2 class="panel-header">필터</h2>
        <div class="form-group">
            <label class="form-label">거리순</label>
            <input type="range" style="width:100%">
        </div>
        <div class="form-group">
            <label class="form-label">운영 여부</label>
            <div class="radio-group">
                <input type="checkbox" id="f1" class="radio-btn" checked><label for="f1" class="radio-label">영업중만
                    보기</label>
            </div>
        </div>
    </aside>

    <div id="main-view">
        <div class="title-text">
            <h1>소음 속의 틈새</h1>
            <p>복잡한 도시 너머, 당신만의 고요한 서울을 만나보세요.</p>
        </div>
        <div class="map-wrapper">
            <svg class="seoul-map" viewBox="0 0 800 600" id="seoul-svg">
                <defs>
                    <filter id="glow">
                        <feGaussianBlur stdDeviation="2.5" result="coloredBlur" />
                        <feMerge>
                            <feMergeNode in="coloredBlur" />
                            <feMergeNode in="SourceGraphic" />
                        </feMerge>
                    </filter>
                </defs>
                <!-- Paths will be generated by JS -->
                <text x="400" y="300" fill="rgba(255,255,255,0.5)" font-size="20" text-anchor="middle"
                    id="loading-text">지도를 불러오는 중...</text>
            </svg>
        </div>
    </div>

    <div id="detail-view">
        <div id="leaflet-map"></div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

    <script>
        // --- Variables ---
        let mapInstance = null;
        let currentMarkers = [];
        const SEOUL_GEOJSON_URL = 'https://raw.githubusercontent.com/southkorea/seoul-maps/master/kostat/2013/json/seoul_municipalities_geo_simple.json';

        // --- Init ---
        document.addEventListener('DOMContentLoaded', () => {
            loadSeoulMap();
        });

        async function loadSeoulMap() {
            try {
                const response = await fetch(SEOUL_GEOJSON_URL);
                const data = await response.json();
                renderGeoJSONToSVG(data);
            } catch (error) {
                console.error('Failed to load map data:', error);
                document.getElementById('loading-text').textContent = "지도를 불러오는데 실패했습니다.";
            }
        }

        function renderGeoJSONToSVG(geojson) {
            const svg = document.getElementById('seoul-svg');
            const loadingText = document.getElementById('loading-text');
            if (loadingText) loadingText.remove();

            // Calculate Bounds
            let minLng = 180, maxLng = -180, minLat = 90, maxLat = -90;
            geojson.features.forEach(feature => {
                feature.geometry.coordinates.forEach(polygon => {
                    // Handle MultiPolygon vs Polygon (GeoJSON simple usually Polygon or MultiPolygon)
                    // The source simple json is usually Polygon or MultiPolygon. 
                    // Let's flatten simply for bounds check.
                    const coords = Array.isArray(polygon[0][0]) ? polygon.flat() : polygon;
                    coords.forEach(pt => {
                        // GeoJSON is [lng, lat]
                        const [lng, lat] = Array.isArray(pt) ? pt : [0, 0]; // Safety
                        if (lng < minLng) minLng = lng;
                        if (lng > maxLng) maxLng = lng;
                        if (lat < minLat) minLat = lat;
                        if (lat > maxLat) maxLat = lat;
                    });
                });
            });

            // Add some padding
            const padding = 0.02;
            minLng -= padding; maxLng += padding;
            minLat -= padding; maxLat += padding;

            const width = 800;
            const height = 600;

            // Projection function (Mercator-ish flip Y)
            function project(lng, lat) {
                const x = (lng - minLng) / (maxLng - minLng) * width;
                const y = height - ((lat - minLat) / (maxLat - minLat) * height); // Flip Y
                return [x, y];
            }

            // Draw Paths
            geojson.features.forEach(feature => {
                const name = feature.properties.name || feature.properties.SIG_KOR_NM; // Adjust based on property keys
                // Simplified logic to handle GeometryCollection or MultiPolygon if needed
                // The linked file usually uses Polygon or MultiPolygon

                let pathData = "";

                const processPolygon = (ring) => {
                    return "M" + ring.map(pt => {
                        const [x, y] = project(pt[0], pt[1]);
                        return `${x},${y}`;
                    }).join(" ") + "Z";
                };

                if (feature.geometry.type === 'Polygon') {
                    pathData = feature.geometry.coordinates.map(processPolygon).join(" ");
                } else if (feature.geometry.type === 'MultiPolygon') {
                    pathData = feature.geometry.coordinates.map(poly => poly.map(processPolygon).join(" ")).join(" ");
                }

                const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
                path.setAttribute("d", pathData);
                path.setAttribute("class", "district-path");
                path.setAttribute("data-name", name);

                // Add click event
                // Find centroid for camera focus
                // Simple centroid approximation
                let cx = 0, cy = 0, k = 0;
                // Just take the first point of the first ring for simplicity or average bounds
                // Better: bounds center

                // We'll use the center of the bounding box of this feature for the Leaflet view
                // Since we don't have per-feature bounds calculated, let's just use the click event to pass the district name
                // and let selectDistrict find coordinates (mocked for now, or we can improve selectDistrict)

                path.onclick = () => {
                    // For the prototype, we can map names to coords or just use the center of the map
                    // Let's pass a rough coordinate based on the bounding box center of the polygon
                    // (Recalculating local bounds)
                    let fMinX = 1000, fMaxX = -1000, fMinY = 1000, fMaxY = -1000;
                    // Scan points again for this feature (inefficient but fine for 25 items)
                    // ... actually let's just pass the name and handle coordinate mapping in selectDistrict 
                    // or pass the map center for now.

                    // Let's calculate a rough centroid from the projected coords to map back to lat/lng?
                    // Easier: just pass the name.
                    selectDistrict(name, 37.5665, 126.9780); // Default center, will be mocked
                };

                // Tooltip/Hover Title
                const title = document.createElementNS("http://www.w3.org/2000/svg", "title");
                title.textContent = name;
                path.appendChild(title);

                svg.appendChild(path);
            });
        }


        // --- UI Logic ---
        function toggleSurvey() {
            document.getElementById('survey-panel').classList.toggle('active');
            // Close filter if open
            document.getElementById('filter-panel').classList.remove('active');
        }

        function toggleFilter() {
            document.getElementById('filter-panel').classList.toggle('active');
            // Close survey if open
            document.getElementById('survey-panel').classList.remove('active');
        }

        function submitSurvey() {
            const resultBox = document.getElementById('survey-result');
            // Simulate processing
            setTimeout(() => {
                resultBox.style.display = 'block';
                resultBox.scrollIntoView({ behavior: 'smooth' });

                // If map is initialized, add mock recommendations
                if (mapInstance) {
                    addRecommendationMarkers();
                } else {
                    // Alert user to select a district first or auto-select one
                    alert("취향 분석 완료! 지도에서 원하는 지역을 선택하여 추천 장소를 확인하세요.");
                }
            }, 500);
        }

        // --- Map Logic ---

        // 1. Select District (Main -> Detail)
        function selectDistrict(name, lat, lng) {
            document.body.classList.add('mode-detail');

            // Initialize Leaflet if not already done
            if (!mapInstance) {
                initLeafletMap(lat, lng);
            } else {
                mapInstance.flyTo([lat, lng], 14, {
                    animate: true,
                    duration: 1.5
                });
            }

            // Mock: Add specific district info or markers
            console.log(`Navigating to ${name}`);
        }

        // 2. Init Leaflet
        function initLeafletMap(lat, lng) {
            mapInstance = L.map('leaflet-map', {
                zoomControl: false, // Move zoom control to conform to design later if needed
                attributionControl: false
            }).setView([lat, lng], 14);

            // Using CartoDB Dark Matter for the "Dark/Modern" look
            L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
                attribution: '&copy; OpenStreetMap &copy; CARTO',
                subdomains: 'abcd',
                maxZoom: 19
            }).addTo(mapInstance);

            // Add Zoom Control to bottom right
            L.control.zoom({
                position: 'bottomright'
            }).addTo(mapInstance);
        }

        // 3. Back to Main
        function goBack() {
            document.body.classList.remove('mode-detail');

            // Reset map view slightly to avoid jarring effect next time
            if (mapInstance) {
                setTimeout(() => {
                    mapInstance.setZoom(12);
                }, 500);
            }
        }

        // 4. Recommendation Markers (Mock Data)
        function addRecommendationMarkers() {
            // Remove existing
            currentMarkers.forEach(m => mapInstance.removeLayer(m));
            currentMarkers = [];

            // Mock Locations around current center
            const center = mapInstance.getCenter();
            const points = [
                { lat: center.lat + 0.005, lng: center.lng + 0.005, title: "숨겨진 한옥 카페" },
                { lat: center.lat - 0.003, lng: center.lng - 0.002, title: "고요한 갤러리 틈" },
                { lat: center.lat + 0.002, lng: center.lng - 0.006, title: "심야 서점" }
            ];

            points.forEach(p => {
                const marker = L.marker([p.lat, p.lng])
                    .addTo(mapInstance)
                    .bindPopup(p.title, { className: 'custom-popup' })
                    .openPopup();
                currentMarkers.push(marker);
            });
        }

        // Close panels when clicking outside (on map)
        document.getElementById('main-view').addEventListener('click', (e) => {
            if (!e.target.closest('.district-path')) {
                document.getElementById('survey-panel').classList.remove('active');
                document.getElementById('filter-panel').classList.remove('active');
            }
        });

    </script>
</body>

</html>